import React, { Component } from "react";
import PropTypes from "prop-types";
import "./Sidebar.css";
import { CompanyName, MenuBox, SidebarInfoBox, BottomMenuBox } from "./widgets";
import {
  BOTTOM_MENU,
  DUMMY_MENU,
  USER_DETAILS,
  SPLIT_KEY,
  DEFAULT_FIRST_LAYER_NAME,
} from "./values";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faArrowLeft, faArrowRight } from "@fortawesome/free-solid-svg-icons";

/**
 *
 * Access the menu schema via the
 * static `.MENU` and `.BOTTOM_MENU` variables
 * First layer menu children must have `id`.
 * Submenu children should not have `id`. (Because That is how we differentiate first layer items from embedded submenu items  )
 * To say an item is on the first layer means, it does not belong in a subMenu.
 * Log `Sidebar.MENU` to get a clear example of what these mean..
 */
export default class Sidebar extends Component {
  static MENU = DUMMY_MENU;
  static BOTTOM_MENU = BOTTOM_MENU;

  constructor(props) {
    super(props);
    this.state = { menuId: null, shrink: false, animationClass: undefined };
    this.handleSidebarStateChange = this.handleSidebarStateChange.bind(this);
    this.onMenuItemClick = this.onMenuItemClick.bind(this);
  }

  componentDidMount() {
    const { shrink } = this.props;
    this.setState({
      shrink,
      animationClass: shrink ? "shrink-animation" : "enlarge",
    });
  }

  /**
   *
   * @param {*} id  of entire menu item obj
   * @param {*} menuKey unique key generated by combining parentName, menuItemName and index
   * @param {*} parentName name of the menu item's parent (NB: every menu item will have a parent name -- even the first layer menus will)
   * @returns
   * NB: For every menu object, whether it is the parent that is selected or a child that is 10 children deep
   * into the parent is selected, they are all added to one flat array "subs". It is the combination of the parentName
   * and the menukey that helps different which layers the menus are on
   */
  onMenuItemClick(id, menuKey, parentName) {
    const { activeMenu } = this.state;
    let ship = { id, subs: [menuKey] };
    const currentId = activeMenu?.id;
    let subs = activeMenu?.subs || [];

    if (!activeMenu || id !== currentId)
      return this.setState({ activeMenu: ship });

    // Means we are dealing with the same menu that has been clicked before
    // check if a child menu item on the same layer has already been selected
    const indexOfAlreadySelectedItemInSameLayer = subs.findIndex(
      (menu) => menu.split(SPLIT_KEY)[0] === parentName
    );

    if (indexOfAlreadySelectedItemInSameLayer > -1) {
      const alreadyExistingItem = subs[indexOfAlreadySelectedItemInSameLayer];
      // if an item is found on the same layer is already selected, remove
      subs.splice(indexOfAlreadySelectedItemInSameLayer, 1);
      //if the item that was just removed was the same as the key that was coming in, no need to do anything else
      if (alreadyExistingItem === menuKey) ship = { id: currentId, subs };
      // means a new menukey from the same layer is coming in, so append to the list of the selected
      else ship = { id: currentId, subs: [...subs, menuKey] };
    } else ship = { id: currentId, subs: [...subs, menuKey] };
    this.setState({ activeMenu: ship });
  }

  handleSidebarStateChange(shrink) {
    // means a shrinking is about to happen
    if (shrink) {
      this.setState({ animationClass: "shrink-animation", shrink });
    } else {
      this.setState({ animationClass: "enlarge" });
      const _this = this;
      setTimeout(() => {
        _this.setState({ shrink });
      }, 250);
    }
  }

  static getDerivedStateFromProps(props, state) {
    if (
      props.defaultActive &&
      !state.activeMenu &&
      props.defaultActive?.id !== state.activeMenu?.id
    ) {
      return {
        activeMenu: {
          id: props.defaultActive?.id,
          subs: [
            DEFAULT_FIRST_LAYER_NAME + SPLIT_KEY + props.defaultActive?.name,
          ],
        },
      };
    }

    return null;
  }

  handleShrinkBtnClick() {
    const { onShrinkBtnClick } = this.props;
    this.handleSidebarStateChange(!this.state.shrink);
    if (onShrinkBtnClick) onShrinkBtnClick();
  }

  handleOnChange() {
    const { onStateChange } = this.props;
    if (onStateChange) onStateChange(this.state);
  }
  render() {
    this.handleOnChange();
    const { dark, userDetails } = this.props;
    const { shrink, animationClass } = this.state;
    const rootClassNames = `sidebar-root-container elevate-float sb-theme${
      dark ? "-dark" : "-light"
    } ${animationClass}`;
    return (
      <div className={rootClassNames}>
        <div className="sidebar-content">
          <div className="shrink-btn-container">
            <button
              className="shrink-btn elevate-float"
              onClick={() => this.handleShrinkBtnClick()}
            >
              {shrink ? (
                <FontAwesomeIcon icon={faArrowRight} />
              ) : (
                <FontAwesomeIcon icon={faArrowLeft} />
              )}
            </button>
          </div>
          <div
            className={`sb-up ${dark ? "sb-up-dark" : "sb-up-light"}`}
            id="company-and-info-container"
          >
            <SidebarInfoBox dark={dark} shrink={shrink} details={userDetails} />
            <CompanyName
              dark={dark}
              shrink={shrink}
              companyName={userDetails && userDetails.companyName}
            />
          </div>
          <MenuBox
            activeMenu={this.state.activeMenu}
            onMenuItemClick={this.onMenuItemClick}
            menu={this.props.menu}
            dark={dark}
            shrink={shrink}
            animationClass={this.state.animationClass}
          />
          <BottomMenuBox
            dark={dark}
            shrink={shrink}
            menu={this.props.bottomMenu}
            activeMenu={this.state.activeMenu}
            onMenuItemClick={this.onMenuItemClick}
          />
        </div>
      </div>
    );
  }
}
Sidebar.propTypes = {
  /** Sets the sidebar to darkmode */
  dark: PropTypes.bool,
  /** Menu data set
   * First layer menu children must have ids.
   */
  menu: PropTypes.arrayOf(PropTypes.object),
  /** Should menu be in full width mode or shrank mode */
  shrink: PropTypes.bool,

  /** The entire menu object of item  that should be pre-hilighted*/
  defaultActive: PropTypes.object,

  /** An object that has user details (companyName, role, userName, companyLogo) */
  details: PropTypes.object,

  /**
   * A function that should run after shrinking is done.
   */
  onShrinkBtnClick: PropTypes.func,

  /**
   * Returns the current state content of the sidebar
   * @param state
   */
  onStateChange: PropTypes.func,
};
Sidebar.defaultProps = {
  dark: false,
  menu: DUMMY_MENU,
  shrink: false,
  userDetails: USER_DETAILS,
  bottomMenu: BOTTOM_MENU,
};

/**
 * Shrinking and anmation works
 * ----------------------------
 * There are two animation classes "enlarge" and "shrink-animation"
 * enlarge animation changes the width of the sidebar to the allowed max width,
 * and shrink-animation does the opposite.
 * When the shrink button is clicked to enlarge,
 * the "shrink-animation" class is set to the state,
 * and the "shrink" value of the state is set to true.
 * ALl the menu text and many other items on the sidebar are set not to show when shrink mode is active so they happen together and gives the shrinking effect.
 *
 * During enlargement:
 * The "enlarge" class is set to the state(animationClassName)
 * When this class is set, the sidebar starts animating first and opening up.
 * While this is happening, the shrink value in the state is set to update in only after 300 miliseconds to give the sidebar sometime to widen up first. At the same time, the remaining menu items that are not controlled by the "shrink" value are set to not show as well until the shrink state is set to false.
 * This is the only way for a smoother width enlargement animation that does not make the sidebar content look like broken packed sardines. looool
 *
 *
 */
